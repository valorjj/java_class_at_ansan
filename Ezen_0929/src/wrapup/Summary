

객체 : [클래스] 설계도 기반으로 생성된 메모리 공간
변수 : [자료형] 하나의 값을 저장할수 있는 메모리 공간
	배열 : 동일한 자료의 변수를 여러개 선언 [ 저장순서 : 인덱스 ]
		배열명.length : 배열의길이 
		
클래스 : 설계도  
	1. System : 시스템 클래스 
		.out.print()
		.out.println()
		.out.printf()
		
	2. Scanner : 입력 클래스 
		Scanner 입력객체 = new Scanner(System.in)
			입력객체.next 
			입력객체.nextLine
			입력객체.nextInt
			
	3. String : 문자열 클래스 
		.equals( 비교문자 ) : 문자 비교 => 동일하면 true 동일하지 않으면 false
	
	4. Random : 난수 클래스 
		.nextInt(숫자) : 0~숫자 전까지의 난수 생성 
		.nextInt(숫자)+1 : 1~숫자 까지의 난수 생성 
		
	5. Arrays : 배열관련 메소드 제공 클래스
		.sort( 배열명 ) : 해당 배열을 오름차순 
		.sort( 배열명, Collections.reverseOrder() ) : 내림차순 
		
형식문자 [ printf ]  
	%d : 정수 	%숫자d [ 숫자만큼 자릿수 포함 ]		%2d [ 정수가 2칸 차지 ] 
	%f : 실수 	%.2f [ 소수점 2자리 표현 ]
	%c : 문자 
	%s : 문자열 
	
제어문자 
	\n : 줄바꿈 
	\t : 들여쓰기 [ 5칸 ]
	\r : 앞칸으로 이동  
	
자료형 
	boolean : 논리 1비트
	char : 문자 2바이트 [유니코드]
	byte : 정수 1바이트 
	short : 정수 2바이트 
	int : 정수 4바이트 [ 기본 정수 자료형 ] 
	long : 정수 8바이트 
	float : 실수 4바이트 [ 소수점 8자리 표현 ] 
	double : 실수 8바이트 [ 소수점 18자리 표현 / 기본 실수 자료형 ] 

산술연산자 : + - * / %
비교연산자 : >= <= > < = !=
논리연산자 : && || !
대입연산자 : = += *= /= %=
증감연산자 : ++ -- 
조건연산자 : 조건식 ? 참 : 거짓 

	제어문 : if , switch
		// if( 조건 ) { 실행문 }
		// else if( 조건2 ) { 실행문 } 
		// else if( 조건3 ) { 실행문 }
		// else { 실행문 }
		
	반복문 : for , while 
		// for( 초기값 ; 조건문 ; 증감식 ) {  실행문 } 
		// [무한루프] while(true){ 실행문 }
			// break; 가장 가까운 반복문 { } 탈출 
			// continue; 가장 가까운 반복문으로 이동 
			
	메모리 : 메모리할당시 주소값[16진수] 부여 [ 바이트당 주소1개 ]
			// 첫번째 주소가 대표 = 배열명, 변수명
			1. 사람 : 변수명 , 자료형 , 값 
			2. 컴퓨터 : 주소값 , 값
			
			
			
			
	함수 / 메소드 : 
		
		
		
		
	// p.256
		// 접근 제한자
		// public : 모든 곳에서 호출 가능
		// private : 현재 클래스내에서만 호출 가능 
		// default : 같은 패키지 내에서 호출 가능 
		// protected : 같은 패키지 내에서 호출 가능. 다른 패키지에 속한 클래스가 해당 클래스의 자식이라면 생성자를 호출할 수 있다.
	
	// p.265
			

상속 : 설계도의 연장 
	* 프로젝트마다 클래스 설계 ---> 시간이 부족해
	* 상속 : 미리 만들어진 클래스로부터 설계도를 제공받아서 이어서 새로운 클래스를 설계한다. 
	* 부모클래스 [superclass]
	* 자식클래스 [subclass]
	* 자바는 다중 상속을 허용하지 않는다. 

오버라이딩 : 부모 클래스의 메소드를 '재정의' 한다. 

상속 :
	1. extends : 연장하다 [설계도연장]
		public class 자식클래스명 extends 부모클래스명 { ... }
	2. super : 부모클래스내 멤버 접근
		1. super() : 부모클래스 내 생성자 호출
		2. super.필드명/메소드명 : 부모클래스 내 필드, 메소드 접근 
	3. @Override : 키워드, 부모클래스 내 메소드 재정의 
	4. final : 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다. 연장 불가능한 마지막 설계도
	
	
	
인터페이스 : 
	* 인터페이스는 객체 사용 설명서 역할
	* 구현 클래스가 인터페이스의 추상 메소드에 대한 실체 메소드를 가지고 있지 않으면 '추상 클래스' 가 된다. 
	* 메소드 ( 인터페이스 )
	* 메소드 ( new 클래스 () ) -> 상속중
	* 위 과정이 가능하다. 클래스로 선언된 객체를 인터페이스가 받을 수 있다. 근데 받는다는게 뭐야 인터페이스가 아니였던 클래스가 적용이 된다는 건가 
	* 인터페이스 배열을 만들어서 다양한 구현 객체를 저장할 수 있다. 
	* 
	
	인터페이스 구성 : 
		상수 	
		추상메소드
		디폴트 메소드
		정적메소드
	* 익명 구현 객체
	Action action = new Action(){
	
	
	};
	
	
- 추상 클래스
	- 실체들의 공통되는 특성을 가지고 있는 추상적인 것 
	- 클래스들의 공통적인 특정을 추출해서 선언한 클래스를 추상 클래스라고 한다. 
	- 추상 클래스 > 실체 클래스 
	- 추상 클래스는 실체 클래스의 공통되는 [필드, 메소드] 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다. new 연산자로 인스턴스를 생성시키지 못한다. 
	- 추상 클래스는 새로운 실체 클래스를 만들기 위해 부모 클래스로'만' 사용된다.  
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	